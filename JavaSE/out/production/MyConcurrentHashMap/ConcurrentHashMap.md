# 什么是线程安全的数据结构？
   简单的说就是不同线程可以访问同一份数据时，它们对这份数据的访问是无序、随机的，是不可控的。
   比如说你的房间谁都可以进来，但是你不确定他们谁先来谁后来或者可能同时来。你想让整件事更有秩序的在你的掌控之中，至少不能同时进来，
   于是就给房间上一把锁，每次只给一个人钥匙，他出来还钥匙之后你再给下一个人。这种带锁或等价机制的数据结构，就是线程安全的。
    
[ConcurrentHashMap的线程安全指的是，它的每个方法单独调用（即原子操作）都是线程安全的，但是代码总体的互斥性并不受控制。]
实际上并不是原子操作，它包含了三步：
1. map.get
2. 加1
3. map.put
   其中第1和第3步，单独来说都是线程安全的，由ConcurrentHashMap保证。但是由于在上面的代码中，map本身是一个共享变量。
当线程A执行map.get的时候，其它线程可能正在执行map.put，这样一来当线程A执行到map.put的时候，线程A的值就已经是脏数据了，
然后脏数据覆盖了真值，导致线程不安全。


   查阅了synchronized的资料后，原来，不管synchronized是用来修饰非静态方法，还是修饰代码块，其本质都是锁定某一个对象。
修饰方法时，锁上的是调用这个方法的对象，即this；修饰代码块时，锁上的是括号里的那个对象
   在上面的代码中，很明显就是锁定的MyTask对象本身。但是由于在每一个线程中，MyTask对象都是独立的，
这就导致实际上每个线程都对自己的MyTask进行锁定，而并不会干涉其它线程的MyTask对象。换言之，上锁压根没有意义


   最后特别补充的是，synchronized关键字判断对象是否是它锁定的对象，本质上是通过 == 运算符来判断的。
换句话说，上面的代码中，可以采用任何一个常量，或者每个线程都共享的变量，或者MyTask类的静态变量，来代替map。
只要该变量与synchronized锁定的目标变量相同（==），就可以使synchronized生效。